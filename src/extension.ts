// extension.ts
import * as vscode from 'vscode';
import * as fs from 'fs';
import * as path from 'path';
import { promisify } from 'util';
import * as crypto from 'crypto';
import * as yaml from 'js-yaml';
import * as cp from 'child_process';

const readFileAsync = promisify(fs.readFile);
const writeFileAsync = promisify(fs.writeFile);
const readdirAsync = promisify(fs.readdir);
const mkdirAsync = promisify(fs.mkdir);
const existsAsync = promisify(fs.exists);

interface PackageJson {
    dependencies?: { [key: string]: string };
    [key: string]: any;
}

export function activate(context: vscode.ExtensionContext) {
    if (!context.globalState.get('codeToYamlWelcomeShown')) {
        vscode.window.showInformationMessage(
            'Welcome to Yamify! Export/import codebases and settings with secure encryption!'
        );
        context.globalState.update('codeToYamlWelcomeShown', true);
    }

    let exportDisposable = vscode.commands.registerCommand('code-to-yaml.convertToYaml', async () => {
        const config = vscode.workspace.getConfiguration('codeToYaml');
        const outputMode = config.get<string>('outputMode', 'fullCode');
        const outputFormat = config.get<string>('outputFormat', 'yaml');
        const workspaceFolders = vscode.workspace.workspaceFolders;
        let outputPath: string;

        try {
            if (!workspaceFolders) {
                vscode.window.showErrorMessage('No workspace folder open');
                return;
            }

            const rootPath = workspaceFolders[0].uri.fsPath;
            outputPath = path.join(rootPath, `codebase.${outputFormat}`);

            if (outputMode === 'fullCode') {
                await convertFullCode(rootPath, outputPath, outputFormat);
            } else if (outputMode === 'modulesAndOverlay') {
                const key = await vscode.window.showInputBox({
                    prompt: 'Enter a unique key for encryption (min 8 chars, remember for import)',
                    password: true,
                    validateInput: (value) => value.length < 8 ? 'Key must be at least 8 characters' : null
                });
                if (!key) return;
                await convertModulesAndOverlay(rootPath, outputPath, outputFormat, key);
            }

            vscode.window.showInformationMessage(`Codebase exported to ${outputPath}`);
            const doc = await vscode.workspace.openTextDocument(outputPath);
            await vscode.window.showTextDocument(doc);
        } catch (error: any) {
            vscode.window.showErrorMessage(`Error converting codebase: ${error.message}`);
        }
    });

    let exportSettingsOnlyDisposable = vscode.commands.registerCommand('code-to-yaml.exportSettingsOnly', async () => {
        const config = vscode.workspace.getConfiguration('codeToYaml');
        const outputFormat = config.get<string>('outputFormat', 'yaml');
        
        try {
            const fileUri = await vscode.window.showSaveDialog({
                defaultUri: vscode.Uri.file(`vscode-settings.${outputFormat}`),
                filters: { 'Configuration': [outputFormat] }
            });
            
            if (!fileUri) return;
            
            await exportSettingsToFile(fileUri.fsPath, outputFormat);
            
            vscode.window.showInformationMessage(`VS Code settings exported to ${fileUri.fsPath}`);
            const doc = await vscode.workspace.openTextDocument(fileUri.fsPath);
            await vscode.window.showTextDocument(doc);
        } catch (error: any) {
            vscode.window.showErrorMessage(`Error exporting settings: ${error.message}`);
        }
    });

    let importDisposable = vscode.commands.registerCommand('code-to-yaml.importFromYaml', async () => {
        const fileUri = await vscode.window.showOpenDialog({
            canSelectMany: false,
            filters: { 'Configuration': ['yaml', 'yml', 'json'] }
        });
        if (!fileUri || !fileUri[0]) return;

        try {
            const content = await readFileAsync(fileUri[0].fsPath, 'utf8');
            const data = fileUri[0].fsPath.endsWith('.json') ? JSON.parse(content) : yaml.load(content);
            
            if (!data.metadata || data.metadata.generator !== 'yamify') {
                vscode.window.showErrorMessage('Invalid file: Must be generated by yamify extension');
                return;
            }

            const workspaceFolders = vscode.workspace.workspaceFolders;
            const rootPath = workspaceFolders?.[0].uri.fsPath;
            let key: string | undefined;

            if (data.metadata.signature) {
                if (data.metadata.mode === 'modulesAndOverlay') {
                    while (true) {
                        key = await vscode.window.showInputBox({
                            prompt: 'Enter the key used to encrypt and sign this file',
                            password: true
                        });
                        if (!key) return;
                        if (verifySignature(data, content, key) && verifyKey(data, key)) break;
                        const retry = await vscode.window.showErrorMessage('Incorrect key or tampered file', 'Try Again');
                        if (retry !== 'Try Again') return;
                    }
                } else {
                    if (!verifySignature(data, content, '')) {
                        vscode.window.showErrorMessage('File tampered or invalid');
                        return;
                    }
                }
            }

            if (data.files) {
                if (!rootPath) {
                    vscode.window.showErrorMessage('Please open a workspace first to import codebase');
                    return;
                }
                
                const options = await vscode.window.showQuickPick(
                    [{ label: 'Codebase Only', value: 'codebase' }],
                    { placeHolder: 'Select what to import from codebase file' }
                );
                if (!options) return;

                await importCodebase(data.files, rootPath, data.metadata.mode === 'modulesAndOverlay' ? key : undefined);
                
                if (data.requirements) {
                    await handleRequirements(data.requirements, rootPath);
                }
            } else if (data.settings) {
                const options = await vscode.window.showQuickPick(
                    [
                        { label: 'Settings Only', value: 'settings' },
                        { label: 'Extensions Only', value: 'extensions' }
                    ],
                    { placeHolder: 'Select what to import from settings file' }
                );
                if (!options) return;

                if (options.value === 'settings') {
                    await importSettings(data.settings);
                } else if (options.value === 'extensions' && data.settings.extensions) {
                    await installExtensions(data.settings.extensions);
                }
            }

            vscode.window.showInformationMessage('Import completed successfully!');
        } catch (error: any) {
            vscode.window.showErrorMessage(`Error importing: ${error.message}`);
        }
    });

    const treeDataProvider = new CodeToYamlTreeProvider();
    vscode.window.createTreeView('codeToYamlView', { treeDataProvider });

    context.subscriptions.push(exportDisposable, exportSettingsOnlyDisposable, importDisposable);
}

async function convertFullCode(rootPath: string, outputPath: string, format: string) {
    const files = await getWorkspaceFiles();
    const requirements = await collectRequirements(files);
    const output: { 
        metadata: { 
            created: string; 
            fileCount: number; 
            mode: string; 
            generator: string;
            signature: string;
        }; 
        files: { [key: string]: string }; 
        requirements?: any 
    } = { 
        metadata: { 
            created: new Date().toISOString(), 
            fileCount: files.length, 
            mode: 'fullCode',
            generator: 'yamify',
            signature: ''
        }, 
        files: {} 
    };

    for (const file of files) {
        const relativePath = path.relative(rootPath, file.fsPath);
        const content = await readFileAsync(file.fsPath, 'utf8');
        output.files[relativePath] = content;
    }

    if (Object.keys(requirements).length > 0) {
        output.requirements = requirements;
    }

    const contentWithoutSignature = JSON.stringify({ ...output, metadata: { ...output.metadata, signature: undefined } });
    output.metadata.signature = crypto.createHash('sha256').update(contentWithoutSignature).digest('hex');

    const finalContent = format === 'yaml'
        ? yaml.dump(output, { lineWidth: -1, noRefs: true })
        : JSON.stringify(output, null, 2);

    await writeFileAsync(outputPath, finalContent);
}

async function convertModulesAndOverlay(rootPath: string, outputPath: string, format: string, key: string) {
    const files = await getWorkspaceFiles();
    const requirements = await collectRequirements(files);
    const output: { 
        metadata: { 
            created: string; 
            fileCount: number; 
            mode: string; 
            generator: string;
            keySignature: string;
            signature: string;
        }; 
        files: { [key: string]: any }; 
        requirements?: any 
    } = { 
        metadata: { 
            created: new Date().toISOString(), 
            fileCount: files.length, 
            mode: 'modulesAndOverlay',
            generator: 'yamify',
            keySignature: crypto.createHmac('sha256', key).update('yamify-verification').digest('hex'),
            signature: ''
        }, 
        files: {} 
    };

    for (const file of files) {
        const relativePath = path.relative(rootPath, file.fsPath);
        const content = await readFileAsync(file.fsPath, 'utf8');
        const encryptedContent = encryptContent(content, key);
        const imports = extractImports(content, path.extname(file.fsPath));
        output.files[relativePath] = { 
            content: encryptedContent, 
            imports, 
            lineCount: content.split('\n').length, 
            extension: path.extname(file.fsPath) 
        };
    }

    if (Object.keys(requirements).length > 0) {
        output.requirements = requirements;
    }

    const contentWithoutSignature = JSON.stringify({ ...output, metadata: { ...output.metadata, signature: undefined } });
    output.metadata.signature = crypto.createHmac('sha256', key).update(contentWithoutSignature).digest('hex');

    const finalContent = format === 'yaml'
        ? yaml.dump(output, { lineWidth: -1, noRefs: true })
        : JSON.stringify(output, null, 2);

    await writeFileAsync(outputPath, finalContent);
}

function encryptContent(content: string, key: string): string {
    const iv = crypto.randomBytes(16);
    const cipher = crypto.createCipheriv('aes-256-cbc', crypto.createHash('sha256').update(key).digest(), iv);
    let encrypted = cipher.update(content, 'utf8', 'hex');
    encrypted += cipher.final('hex');
    return iv.toString('hex') + ':' + encrypted;
}

function decryptContent(encrypted: string, key: string): string {
    const [ivHex, encryptedHex] = encrypted.split(':');
    const iv = Buffer.from(ivHex, 'hex');
    const decipher = crypto.createDecipheriv('aes-256-cbc', crypto.createHash('sha256').update(key).digest(), iv);
    let decrypted = decipher.update(encryptedHex, 'hex', 'utf8');
    decrypted += decipher.final('utf8');
    return decrypted;
}

function verifyKey(data: any, key: string): boolean {
    const expectedKeySignature = crypto.createHmac('sha256', key).update('yamify-verification').digest('hex');
    const result = data.metadata.keySignature === expectedKeySignature;
    console.log(`Key Verification: Expected ${expectedKeySignature}, Got ${data.metadata.keySignature}, Result: ${result}`);
    return result;
}

function verifySignature(data: any, content: string, key: string): boolean {
    const contentWithoutSignature = JSON.stringify({ ...data, metadata: { ...data.metadata, signature: undefined } });
    const expectedSignature = data.metadata.mode === 'modulesAndOverlay'
        ? crypto.createHmac('sha256', key).update(contentWithoutSignature).digest('hex')
        : crypto.createHash('sha256').update(contentWithoutSignature).digest('hex');
    const result = data.metadata.signature === expectedSignature;
    console.log(`Signature Verification: Expected ${expectedSignature}, Got ${data.metadata.signature}, Result: ${result}`);
    return result;
}

async function exportSettingsToFile(outputPath: string, format: string) {
    const settingsData = await getCompleteSettings();
    const output = { 
        metadata: { 
            created: new Date().toISOString(), 
            generator: 'yamify',
            signature: ''
        }, 
        settings: settingsData 
    };
    const contentWithoutSignature = JSON.stringify({ ...output, metadata: { ...output.metadata, signature: undefined } });
    output.metadata.signature = crypto.createHash('sha256').update(contentWithoutSignature).digest('hex');
    
    const finalContent = format === 'yaml'
        ? yaml.dump(output, { lineWidth: -1, noRefs: true })
        : JSON.stringify(output, null, 2);
    await writeFileAsync(outputPath, finalContent);
}

async function getWorkspaceFiles(): Promise<vscode.Uri[]> {
    const includePatterns = [
        '**/*.ts', '**/*.js', '**/*.py', '**/*.java',
        '**/*.cpp', '**/*.c', '**/*.rb', '**/*.go',
        '**/*.rs', '**/*.php', '**/*.cs', '**/*.html',
        '**/*.css', '**/*.jsx', '**/*.tsx'
    ];
    
    const excludePatterns = [
        // Common build and distribution directories
        '**/node_modules/**', '**/dist/**', '**/build/**', '**/out/**', '**/target/**',
        '**/bin/**', '**/obj/**', '**/lib/**', '**/output/**', '**/release/**', '**/debug/**',
        
        // Version control
        '**/.git/**', '**/.svn/**', '**/.hg/**',
        
        // IDE and editor specific
        '**/.vs/**', '**/.vscode/**', '**/.idea/**', '**/.fleet/**', '**/.eclipse/**',
        '**/.settings/**', '**/.project/**', '**/.classpath/**', '**/.metadata/**',
        
        // Cache directories
        '**/.cache/**', '**/__pycache__/**', '**/.pytest_cache/**', '**/.mypy_cache/**',
        '**/.nyc_output/**', '**/coverage/**',
        
        // Language-specific generated files
        '**/vendor/**', '**/venv/**', '**/.env/**', '**/env/**',
        '**/packages/**', '**/bower_components/**', '**/jspm_packages/**',
        '**/compiled/**', '**/generated/**', '**/autogen/**', '**/auto-generated/**',
        
        // Minified files
        '**/*.min.js', '**/*.min.css',
        
        // Logs and temporary files
        '**/logs/**', '**/tmp/**', '**/temp/**', '**/.next/**',
        
        // Documentation
        '**/docs/**', '**/documentation/**'
    ];
    
    return await vscode.workspace.findFiles(
        `{${includePatterns.join(',')}}`,
        `{${excludePatterns.join(',')}}`
    );
}

async function getCompleteSettings(): Promise<any> {
    const settings: any = {};
    const configDir = process.env.APPDATA
        ? path.join(process.env.APPDATA, 'Code', 'User')
        : path.join(process.env.HOME || '~', '.config', 'Code', 'User');

    const settingsPath = path.join(configDir, 'settings.json');
    if (fs.existsSync(settingsPath)) {
        settings.settings = JSON.parse(await readFileAsync(settingsPath, 'utf8'));
    }

    const keybindingsPath = path.join(configDir, 'keybindings.json');
    if (fs.existsSync(keybindingsPath)) {
        settings.keybindings = JSON.parse(await readFileAsync(keybindingsPath, 'utf8'));
    }

    const snippetsDir = path.join(configDir, 'snippets');
    if (fs.existsSync(snippetsDir)) {
        const snippetFiles = await readdirAsync(snippetsDir);
        settings.snippets = {};
        for (const file of snippetFiles) {
            if (file.endsWith('.json')) {
                const snippetContent = JSON.parse(await readFileAsync(path.join(snippetsDir, file), 'utf8'));
                settings.snippets[file] = snippetContent;
            }
        }
    }

    if (vscode.workspace.workspaceFolders) {
        const workspaceFolder = vscode.workspace.workspaceFolders[0];
        const vscodeFolder = path.join(workspaceFolder.uri.fsPath, '.vscode');
        
        if (fs.existsSync(vscodeFolder)) {
            settings.workspace = {};
            
            const tasksPath = path.join(vscodeFolder, 'tasks.json');
            if (fs.existsSync(tasksPath)) {
                settings.workspace.tasks = JSON.parse(await readFileAsync(tasksPath, 'utf8'));
            }
            
            const launchPath = path.join(vscodeFolder, 'launch.json');
            if (fs.existsSync(launchPath)) {
                settings.workspace.launch = JSON.parse(await readFileAsync(launchPath, 'utf8'));
            }
        }
    }

    settings.extensions = await getInstalledExtensions();
    return settings;
}

async function getInstalledExtensions(): Promise<string[]> {
    return new Promise((resolve, reject) => {
        const command = process.platform === 'win32'
            ? 'code.cmd --list-extensions'
            : 'code --list-extensions';
            
        cp.exec(command, (error, stdout, stderr) => {
            if (error) {
                const extensions = vscode.extensions.all
                    .filter(ext => !ext.packageJSON.isBuiltin)
                    .map(ext => `${ext.packageJSON.publisher}.${ext.packageJSON.name}`);
                resolve(extensions);
                return;
            }
            
            const extensions = stdout.trim().split('\n');
            resolve(extensions);
        });
    });
}

async function installExtensions(extensions: string[]): Promise<void> {
    return vscode.window.withProgress({
        location: vscode.ProgressLocation.Notification,
        title: "Installing extensions",
        cancellable: true
    }, async (progress, token) => {
        const total = extensions.length;
        let installed = 0;
        
        for (const ext of extensions) {
            if (token.isCancellationRequested) break;
            
            try {
                const isInstalled = vscode.extensions.getExtension(ext);
                if (!isInstalled) {
                    const command = process.platform === 'win32'
                        ? `code.cmd --install-extension ${ext}`
                        : `code --install-extension ${ext}`;
                    
                    await new Promise<void>((resolve, reject) => {
                        cp.exec(command, (error) => {
                            if (error) {
                                vscode.window.showWarningMessage(`Failed to install extension: ${ext}`);
                            }
                            resolve();
                        });
                    });
                }
                
                installed++;
                progress.report({ 
                    message: `${installed}/${total}: ${ext}`,
                    increment: (1 / total) * 100
                });
            } catch (error) {
                vscode.window.showWarningMessage(`Failed to install extension: ${ext}`);
            }
        }
    });
}

async function importSettings(settingsData: any) {
    const configDir = process.env.APPDATA
        ? path.join(process.env.APPDATA, 'Code', 'User')
        : path.join(process.env.HOME || '~', '.config', 'Code', 'User');

    if (!await existsAsync(configDir)) {
        await mkdirAsync(configDir, { recursive: true });
    }

    if (settingsData.settings) {
        const settingsPath = path.join(configDir, 'settings.json');
        await writeFileAsync(settingsPath, JSON.stringify(settingsData.settings, null, 2));
    }

    if (settingsData.keybindings) {
        const keybindingsPath = path.join(configDir, 'keybindings.json');
        await writeFileAsync(keybindingsPath, JSON.stringify(settingsData.keybindings, null, 2));
    }

    if (settingsData.snippets) {
        const snippetsDir = path.join(configDir, 'snippets');
        if (!await existsAsync(snippetsDir)) {
            await mkdirAsync(snippetsDir, { recursive: true });
        }
        
        for (const [fileName, content] of Object.entries(settingsData.snippets)) {
            await writeFileAsync(path.join(snippetsDir, fileName), JSON.stringify(content as any, null, 2));
        }
    }

    if (settingsData.workspace && vscode.workspace.workspaceFolders) {
        const workspaceFolder = vscode.workspace.workspaceFolders[0];
        const vscodeFolder = path.join(workspaceFolder.uri.fsPath, '.vscode');
        
        if (!await existsAsync(vscodeFolder)) {
            await mkdirAsync(vscodeFolder, { recursive: true });
        }
        
        if (settingsData.workspace.tasks) {
            const tasksPath = path.join(vscodeFolder, 'tasks.json');
            await writeFileAsync(tasksPath, JSON.stringify(settingsData.workspace.tasks, null, 2));
        }
        
        if (settingsData.workspace.launch) {
            const launchPath = path.join(vscodeFolder, 'launch.json');
            await writeFileAsync(launchPath, JSON.stringify(settingsData.workspace.launch, null, 2));
        }
    }

    const reload = await vscode.window.showInformationMessage('Settings imported. Reload VS Code to apply?', 'Reload', 'Later');
    if (reload === 'Reload') vscode.commands.executeCommand('workbench.action.reloadWindow');
}

async function importCodebase(files: { [key: string]: any }, rootPath: string, key?: string) {
    for (const [relativePath, fileData] of Object.entries(files)) {
        const fullPath = path.join(rootPath, relativePath);
        const dir = path.dirname(fullPath);
        
        if (!await existsAsync(dir)) {
            await mkdirAsync(dir, { recursive: true });
        }
        
        let content: string;
        if (typeof fileData === 'string') {
            content = fileData;
        } else if (key && fileData.content) {
            content = decryptContent(fileData.content, key);
        } else {
            continue;
        }
        
        await writeFileAsync(fullPath, content);
    }
    vscode.window.showInformationMessage(`Codebase files imported to ${rootPath}`);
}

async function collectRequirements(files: vscode.Uri[]): Promise<any> {
    const requirements: any = {};
    
    for (const file of files) {
        const content = await readFileAsync(file.fsPath, 'utf8');
        const ext = path.extname(file.fsPath).toLowerCase();
        const imports = extractImports(content, ext);
        
        switch (ext) {
            case '.js': case '.ts': case '.jsx': case '.tsx':
                requirements.npm = requirements.npm || [];
                imports.forEach(imp => {
                    const match = imp.match(/from\s+['"]([^'"]+)['"]/);
                    if (match && !match[1].startsWith('.') && !match[1].startsWith('/')) {
                        requirements.npm.push(match[1]);
                    }
                });
                break;
            case '.py':
                requirements.pip = requirements.pip || [];
                imports.forEach(imp => {
                    const match = imp.match(/^\s*(?:from\s+([\w.]+)\s+import|import\s+([\w.]+))/);
                    if (match) {
                        const module = match[1] || match[2];
                        if (module && !module.includes('.')) {
                            requirements.pip.push(module);
                        }
                    }
                });
                break;
            case '.go':
                requirements.go = requirements.go || [];
                imports.forEach(imp => {
                    const match = imp.match(/["']([^"']+)["']/);
                    if (match) requirements.go.push(match[1]);
                });
                break;
            case '.rb':
                requirements.gem = requirements.gem || [];
                imports.forEach(imp => {
                    const match = imp.match(/['"]([^'"]+)['"]/);
                    if (match) requirements.gem.push(match[1]);
                });
                break;
        }
    }
    
    for (const key in requirements) {
        requirements[key] = [...new Set(requirements[key])];
    }
    
    return requirements;
}

async function handleRequirements(requirements: any, rootPath: string) {
    let instructions = 'Required dependencies:\n';
    
    if (requirements.npm) {
        instructions += `\nNPM packages (run in ${rootPath}):\nnpm install ${requirements.npm.join(' ')}\n`;
        const packageJsonPath = path.join(rootPath, 'package.json');
        let packageJson: PackageJson = {};
        if (await existsAsync(packageJsonPath)) {
            packageJson = JSON.parse(await readFileAsync(packageJsonPath, 'utf8'));
        }
        packageJson.dependencies = packageJson.dependencies || {};
        requirements.npm.forEach((dep: string) => {
            packageJson.dependencies![dep] = 'latest';
        });
        await writeFileAsync(packageJsonPath, JSON.stringify(packageJson, null, 2));
    }
    
    if (requirements.pip) {
        instructions += `\nPython packages:\npip install ${requirements.pip.join(' ')}\n`;
    }
    
    if (requirements.go) {
        instructions += `\nGo modules (run in ${rootPath}):\n${requirements.go.map((mod: string) => `go get ${mod}`).join('\n')}\n`;
    }
    
    if (requirements.gem) {
        instructions += `\nRuby gems:\ngem install ${requirements.gem.join(' ')}\n`;
    }
    
    if (instructions !== 'Required dependencies:\n') {
        await vscode.window.showInformationMessage(instructions, 'Copy to Clipboard')
            .then(choice => {
                if (choice === 'Copy to Clipboard') {
                    vscode.env.clipboard.writeText(instructions);
                }
            });
    }
}

function extractImports(content: string, extension: string): string[] {
    const imports: string[] = [];
    const lines = content.split('\n');

    switch (extension.toLowerCase()) {
        case '.js': case '.ts': case '.jsx': case '.tsx':
            lines.forEach(line => {
                if (line.match(/import.*from\s*['"].*['"]/)) imports.push(line.trim());
                else if (line.match(/require\(['"].*['"]\)/)) imports.push(line.trim());
            });
            break;
        case '.py':
            lines.forEach(line => {
                if (line.match(/^\s*(import\s+[\w.]+|from\s+[\w.]+\s+import)/)) imports.push(line.trim());
            });
            break;
        case '.java':
            lines.forEach(line => {
                if (line.match(/^\s*import\s+[\w.]+(\.\*|\w+);/)) imports.push(line.trim());
            });
            break;
        case '.cpp': case '.c': case '.h': case '.hpp':
            lines.forEach(line => {
                if (line.match(/^\s*#include\s+["<][^">]+[">]/)) imports.push(line.trim());
            });
            break;
        case '.rb':
            lines.forEach(line => {
                if (line.match(/^\s*require\s+['"].*['"]/)) imports.push(line.trim());
            });
            break;
        case '.go':
            let inImportBlock = false;
            lines.forEach(line => {
                if (line.match(/^\s*import\s*\(/)) inImportBlock = true;
                else if (line.match(/^\s*\)/) && inImportBlock) inImportBlock = false;
                else if ((inImportBlock || line.match(/^\s*import\s+["']/)) && line.match(/["'].*["']/)) imports.push(line.trim());
            });
            break;
        case '.rs':
            lines.forEach(line => {
                if (line.match(/^\s*use\s+[\w:]+(\s*::\s*\w+)*;/)) imports.push(line.trim());
            });
            break;
        case '.php':
            lines.forEach(line => {
                if (line.match(/^\s*use\s+[\w\\]+(\s+as\s+\w+)?;/) || line.match(/^\s*(require|include)(_once)?\s+['"].*['"]/)) imports.push(line.trim());
            });
            break;
        case '.cs':
            lines.forEach(line => {
                if (line.match(/^\s*using\s+[\w.]+;/)) imports.push(line.trim());
            });
            break;
        case '.html':
            lines.forEach(line => {
                if (line.match(/<script\s+.*src=['"].*['"]>/)) imports.push(line.trim());
                else if (line.match(/<link\s+.*href=['"].*['"].*rel=['"]stylesheet['"]>/)) imports.push(line.trim());
            });
            break;
        case '.css':
            lines.forEach(line => {
                if (line.match(/^\s*@import\s+['"].*['"];/)) imports.push(line.trim());
            });
            break;
        default:
            lines.forEach(line => {
                if (line.match(/^\s*(import|require|use|include|#include)\s+['"<]?[\w./:-]+['">]?/)) imports.push(line.trim());
            });
            break;
    }
    return imports;
}

class CodeToYamlTreeProvider implements vscode.TreeDataProvider<vscode.TreeItem> {
    private _onDidChangeTreeData: vscode.EventEmitter<vscode.TreeItem | undefined | null> = new vscode.EventEmitter<vscode.TreeItem | undefined | null>();
    readonly onDidChangeTreeData: vscode.Event<vscode.TreeItem | undefined | null> = this._onDidChangeTreeData.event;

    refresh(): void {
        this._onDidChangeTreeData.fire(null);
    }
    
    getTreeItem(element: vscode.TreeItem): vscode.TreeItem {
        return element;
    }

    getChildren(element?: vscode.TreeItem): Thenable<vscode.TreeItem[]> {
        if (element) return Promise.resolve([]);
        
        const fullConvertItem = new vscode.TreeItem('Convert Full Codebase', vscode.TreeItemCollapsibleState.None);
        fullConvertItem.command = { command: 'code-to-yaml.convertToYaml', title: 'Convert Codebase' };
        fullConvertItem.tooltip = 'Export entire codebase with dependencies (full or encrypted)';
        fullConvertItem.iconPath = new vscode.ThemeIcon('archive');
        
        const exportSettingsItem = new vscode.TreeItem('Export Settings Only', vscode.TreeItemCollapsibleState.None);
        exportSettingsItem.command = { command: 'code-to-yaml.exportSettingsOnly', title: 'Export Settings Only' };
        exportSettingsItem.tooltip = 'Export VS Code settings, snippets, and extensions';
        exportSettingsItem.iconPath = new vscode.ThemeIcon('settings-gear');
        
        const importItem = new vscode.TreeItem('Import Code/Settings', vscode.TreeItemCollapsibleState.None);
        importItem.command = { command: 'code-to-yaml.importFromYaml', title: 'Import Code/Settings' };
        importItem.tooltip = 'Import code or settings from a file';
        importItem.iconPath = new vscode.ThemeIcon('cloud-download');
        
        const changeSettingsItem = new vscode.TreeItem('Change Extension Settings', vscode.TreeItemCollapsibleState.None);
        changeSettingsItem.command = { command: 'workbench.action.openSettings', title: 'Open Settings', arguments: ['codeToYaml'] };
        changeSettingsItem.tooltip = 'Adjust output mode and format';
        changeSettingsItem.iconPath = new vscode.ThemeIcon('gear');
        
        const whyUseItem = new vscode.TreeItem('Why Use This?', vscode.TreeItemCollapsibleState.None);
        whyUseItem.command = { command: 'vscode.open', title: 'Learn More', arguments: [vscode.Uri.parse('https://example.com/code-to-yaml-use-cases')] };
        whyUseItem.tooltip = 'Learn how to use this with AI, docs, and customization';
        whyUseItem.iconPath = new vscode.ThemeIcon('question');
        
        return Promise.resolve([
            fullConvertItem,
            exportSettingsItem,
            importItem,
            changeSettingsItem,
            whyUseItem
        ]);
    }
}

export function deactivate() {}